using System;
using System.Linq;
using System.IO;
using System.Threading;
using log4net;
using OpenHome.Net.Device;
using System.Collections.Generic;
using OpenHome.Net.Device.Providers;
using OpenHome.Os.Platform;
using OpenHome.Os.Platform.Collections;

// !!!! need IOsContext definition
// !!!! which may include interface to proxy for InstallManager service

namespace OpenHome.Os.Apps
{
    public enum AppState
    {
        Running,
        NotRunning,
    }

    public class AppInfo
    {
        public string Name { get; set; }
        public AppState State { get; set; }
        public bool PendingUpdate { get; set; }
        public bool PendingDelete { get; set; }
        public string Udn { get; set; }
        public string FriendlyName { get; set; }
        public bool AutoUpdate { get; set; }
        public string UpdateUrl { get; set; }
        public string IconUrl { get; set; }
        public AppVersion Version { get; set; }
        public DateTime? DownloadLastModified { get; set; }

        public AppInfo(
            string aName,
            AppState aState,
            bool aPendingUpdate,
            bool aPendingDelete,
            string aUdn,
            string aFriendlyName,
            bool aAutoUpdate,
            string aUpdateUrl,
            string aIconUrl,
            AppVersion aVersion,
            DateTime? aDownloadLastModified)
        {
            Name = aName;
            State = aState;
            PendingUpdate = aPendingUpdate;
            PendingDelete = aPendingDelete;
            Udn = aUdn;
            FriendlyName = aFriendlyName;
            AutoUpdate = aAutoUpdate;
            UpdateUrl = aUpdateUrl;
            IconUrl = aIconUrl;
            Version = aVersion;
            DownloadLastModified = aDownloadLastModified;
        }

        // Equality members auto-generated by Resharper:

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != typeof (AppInfo)) return false;
            return Equals((AppInfo) obj);
        }

        public bool Equals(AppInfo other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return Equals(other.Name, Name) &&
                Equals(other.State, State) &&
                other.PendingUpdate.Equals(PendingUpdate) &&
                other.PendingDelete.Equals(PendingDelete) &&
                Equals(other.Udn, Udn) &&
                Equals(other.FriendlyName, FriendlyName) &&
                other.AutoUpdate.Equals(AutoUpdate) &&
                Equals(other.UpdateUrl, UpdateUrl) &&
                Equals(other.IconUrl, IconUrl) &&
                Equals(other.Version, Version);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int result = (Name != null ? Name.GetHashCode() : 0);
                result = (result*397) ^ State.GetHashCode();
                result = (result*397) ^ PendingUpdate.GetHashCode();
                result = (result*397) ^ PendingDelete.GetHashCode();
                result = (result*397) ^ (Udn != null ? Udn.GetHashCode() : 0);
                result = (result*397) ^ (FriendlyName != null ? FriendlyName.GetHashCode() : 0);
                result = (result*397) ^ AutoUpdate.GetHashCode();
                result = (result*397) ^ (UpdateUrl != null ? UpdateUrl.GetHashCode() : 0);
                result = (result*397) ^ (IconUrl != null ? IconUrl.GetHashCode() : 0);
                result = (result*397) ^ (Version != null ? Version.GetHashCode() : 0);
                return result;
            }
        }

        public static bool operator ==(AppInfo left, AppInfo right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(AppInfo left, AppInfo right)
        {
            return !Equals(left, right);
        }

        // End of equality members auto-generated by Resharper.
    }

    /// <summary>
    /// Hosts apps in a process.
    /// Not thread-safe: do not invoke methods from multiple threads simultaneously.
    /// </summary>
    public class AppShellImpl : IDisposable
    {
        static readonly ILog Logger = LogManager.GetLogger(typeof(AppShellImpl));
        private class PublishedApp : IDisposable
        {
            public IApp App { get { return iApp; } }
            public string Udn { get { return iUdn; } }
            private readonly IApp iApp;
            private readonly IDvDevice iDevice;
            private readonly IDvProviderOpenhomeOrgApp1 iProvider;
            readonly string iUdn;

            public PublishedApp(IApp aApp, IDvDevice aDevice, IDvProviderOpenhomeOrgApp1 aProvider)
            {
                iApp = aApp;
                iDevice = aDevice;
                iProvider = aProvider;
                iUdn = aDevice.Udn();
            }
            public void Dispose()
            {
                Semaphore disposeSemaphore = new Semaphore(0,1);
                iDevice.SetDisabled(() => disposeSemaphore.Release());
                disposeSemaphore.WaitOne();
                ((IDisposable)disposeSemaphore).Dispose();
                iApp.Stop(); // ???
                iApp.Dispose();
                iDevice.Dispose();
                iProvider.Dispose();
            }
        }

        private class KnownApp
        {
            readonly IAppMetadataStore iMetadataStore;
            readonly IAppsDirectory iAppsDirectory;
            readonly IZipVerifier iZipVerifier;

            public string AppName { get; private set; }

            public void WriteAppMetadata(AppMetadata value)
            {
                if (value.AppName != AppName)
                {
                    throw new ArgumentException("AppMetadata has incorrect AppName");
                }
                iMetadataStore.PutApp(value);
            }

            public AppMetadata ReadAppMetadata()
            {
                return iMetadataStore.GetApp(AppName);
            }

            public KnownApp(string aAppName, IAppMetadataStore aMetadataStore, IAppsDirectory aAppsDirectory, IZipVerifier aZipVerifier)
            {
                AppName = aAppName;
                iMetadataStore = aMetadataStore;
                iZipVerifier = aZipVerifier;
                iAppsDirectory = aAppsDirectory;
                IconUrl = "";
            }

            public PublishedApp PublishedApp { get; private set; }
            public bool IsPublished { get { return PublishedApp != null; } }
            public bool DirectoryExists { get { return iAppsDirectory.DoesSubdirectoryExist(AppName); } }
            public bool HasCodeLoaded { get; private set; }
            public string IconUrl { get; set; }
            public AppVersion Version { get; set; }

            public void Publish(PublishedApp aPublishedApp)
            {
                // Regardless of whether we succeed to publish, record that we've
                // loaded code for this app, because it will stop us from deleting
                // it later, even if it is first unpublished.
                HasCodeLoaded = true;
                if (IsPublished)
                {
                    throw new InvalidOperationException("App is already published.");
                }
                PublishedApp = aPublishedApp;
            }

            public void DeleteNow()
            {
                if (IsPublished)
                {
                    throw new InvalidOperationException("Cannot delete a published app.");
                }
                if (HasCodeLoaded)
                {
                    throw new InvalidOperationException("Cannot delete an app while it has code loaded.");
                }
                Logger.InfoFormat("Delete app {0}", AppName);
                if (iAppsDirectory.DoesSubdirectoryExist(AppName))
                {
                    iAppsDirectory.DeleteSubdirectory(AppName, true);
                }
                iMetadataStore.DeleteApp(AppName);
            }

            void ScheduleDelete()
            {
                Logger.InfoFormat("Mark app for delete: {0}", AppName);
                var metadata = ReadAppMetadata();
                metadata.DeletePending = true;
                WriteAppMetadata(metadata);
                Logger.InfoFormat("App marked for delete: {0}", AppName);
            }

            public void Delete()
            {
                ScheduleDelete();
                if (!HasCodeLoaded)
                {
                    DeleteNow();
                }
            }

            public void Unpublish()
            {
                if (!IsPublished)
                {
                    throw new InvalidOperationException("App is not published.");
                }
                PublishedApp.Dispose();
                PublishedApp = null;
            }

            public void Upgrade(string aPersistentLocalPath)
            {
                ScheduleUpgrade(aPersistentLocalPath);
                if (!HasCodeLoaded)
                {
                    UpgradeNow();
                }
            }

            void ScheduleUpgrade(string aPersistentLocalPath)
            {
                Logger.InfoFormat("Mark app for upgrade: {0}", AppName);
                var metadata = ReadAppMetadata();
                metadata.LocalInstallLocation = aPersistentLocalPath;
                metadata.InstallPending = true;
                // If we previously scheduled a delete, the install supercedes it.
                metadata.DeletePending = false;
                WriteAppMetadata(metadata);
            }

            public void UpgradeNow()
            {
                Logger.InfoFormat("Install/upgrade app {0}", AppName);
                if (HasCodeLoaded)
                {
                    throw new InvalidOperationException("Cannot upgrade an app while it has code loaded.");
                }
                var metadata = ReadAppMetadata();
                string zipAppName = iZipVerifier.VerifyPluginZip(metadata.LocalInstallLocation);
                if (zipAppName != AppName)
                {
                    metadata.InstallPending = false;
                    WriteAppMetadata(metadata);
                    Logger.WarnFormat(
                        "App upgrade rejected because app name didn't match. Expected '{0}', but found '{1}' inside '{2}'.",
                        AppName, zipAppName, metadata.LocalInstallLocation);
                    return;
                }
                if (iAppsDirectory.DoesSubdirectoryExist(AppName))
                {
                    iAppsDirectory.DeleteSubdirectory(AppName, true);
                }
                iAppsDirectory.InstallZipFile(metadata.LocalInstallLocation);
                metadata.InstallPending = false;
                WriteAppMetadata(metadata);
            }

            public void ResolvePendingOperations()
            {
                if (HasCodeLoaded)
                {
                    throw new InvalidOperationException("Cannot resolve pending operations while app has code loaded.");
                }
                var metadata = ReadAppMetadata();
                if (metadata.DeletePending)
                {
                    DeleteNow();
                    return;
                }
                if (metadata.InstallPending)
                {
                    UpgradeNow();
                }
            }
            
        }

        private readonly List<HistoryItem> iHistory;
        readonly IAppServices iFullPrivilegeAppServices;
        private readonly IConfigFileCollection iConfiguration;
        bool iAppsStarted;
        readonly IAddinManager iAddinManager;
        readonly IAppsDirectory iAppsDirectory;
        readonly IStoreDirectory iStoreDirectory;
        readonly Func<DvDevice, IApp, string, IDvProviderOpenhomeOrgApp1> iAppProviderConstructor;
        //readonly IZipReader iZipReader;
        readonly IAppMetadataStore iMetadataStore;
        readonly IZipVerifier iZipVerifier;
        readonly INodeRebooter iNodeRebooter;
        readonly Bimap<string, string> iUdnsToAppNamesBimap = new Bimap<string, string>();

        IDictionary<string, string> UdnsToAppNames { get { return iUdnsToAppNamesBimap.Forward; } }
        IDictionary<string, string> AppNamesToUdns { get { return iUdnsToAppNamesBimap.Backward; } }
        readonly Dictionary<string, KnownApp> iKnownApps = new Dictionary<string, KnownApp>();

        public List<HistoryItem> History
        {
            get { return new List<HistoryItem>(iHistory); }
        }

        EventHandler<AppStatusChangeEventArgs> iAppStatusChanged;
        public event EventHandler<AppStatusChangeEventArgs> AppStatusChanged
        {
            add { iAppStatusChanged += value; }
            remove { iAppStatusChanged -= value; }
        }

        public void InvokeAppStatusChanged(AppStatusChangeEventArgs aE)
        {
            EventHandler<AppStatusChangeEventArgs> handler = iAppStatusChanged;
            if (handler != null) handler(this, aE);
        }

        public AppShellImpl(
            IAppServices aFullPrivilegeAppServices,
            IConfigFileCollection aConfiguration,
            IAddinManager aAddinManager,
            IAppsDirectory aAppsDirectory,
            IStoreDirectory aStoreDirectory,
            Func<DvDevice, IApp, string, IDvProviderOpenhomeOrgApp1> aAppProviderConstructor,
            IZipReader aZipReader,
            IAppMetadataStore aMetadataStore,
            IZipVerifier aZipVerifier,
            bool aAutoStart)
        {
            iFullPrivilegeAppServices = aFullPrivilegeAppServices;
            iZipVerifier = aZipVerifier;
            //iZipReader = aZipReader;
            iMetadataStore = aMetadataStore;
            iConfiguration = aConfiguration;
            iAddinManager = aAddinManager;
            iAppsDirectory = aAppsDirectory;
            iStoreDirectory = aStoreDirectory;
            iAppProviderConstructor = aAppProviderConstructor;
            iNodeRebooter = iFullPrivilegeAppServices.NodeRebooter;
            //iApps = new Dictionary<string, PublishedApp>();
            iHistory = new List<HistoryItem>();
            // !!!! restore previous history from disk
            iKnownApps = new Dictionary<string, KnownApp>();
            foreach (var app in iMetadataStore.LoadAppsFromStore())
            {
                GetOrCreateKnownApp(app.AppName);
            }
            foreach (string dirname in iAppsDirectory.GetAppSubdirectories())
            {
                GetOrCreateKnownApp(dirname);
            }
            if (aAutoStart)
            {
                Start();
            }
        }

        public IEnumerable<AppInfo> GetApps()
        {
            List<AppInfo> apps = new List<AppInfo>();
            foreach (var app in iKnownApps.Values)
            {
                var metadata = app.ReadAppMetadata();
                string udn = null;
                string friendlyName = "";
                bool autoUpdate = false;
                string updateUrl = "";
                if (metadata != null)
                {
                    udn = metadata.Udn;
                    friendlyName = metadata.FriendlyName;
                    autoUpdate = metadata.AutoUpdate;
                    updateUrl = metadata.UpdateUrl;
                }
                apps.Add(new AppInfo(
                    app.AppName,
                    app.IsPublished ? AppState.Running : AppState.NotRunning,
                    metadata!=null && metadata.InstallPending,
                    metadata!=null && metadata.DeletePending,
                    udn,
                    friendlyName,
                    autoUpdate,
                    updateUrl,
                    app.IconUrl,
                    app.Version,
                    metadata!=null ? metadata.LastModified : null
                    ));
            }
            return apps;
        }

        KnownApp GetOrCreateKnownApp(string aAppName)
        {
            if (aAppName == null) throw new ArgumentNullException("aAppName");
            KnownApp app;
            if (!iKnownApps.TryGetValue(aAppName, out app))
            {
                app = new KnownApp(aAppName, iMetadataStore, iAppsDirectory, iZipVerifier);
                iKnownApps[aAppName] = app;
            }
            if (app.ReadAppMetadata() == null)
            {
                app.WriteAppMetadata(
                    new AppMetadata
                    {
                        AppName = aAppName,
                        DeletePending = false,
                        GrantedPermissions = new List<string>(),
                        InstallPending = false,
                        LocalInstallLocation = null
                    });
            }
            return app;
        }

        public void Start()
        {
            if (iAppsStarted) return;
            iAppsStarted = true;
            List<string> deletedApps = new List<string>();
            foreach (var knownApp in iKnownApps.Values)
            {
                knownApp.ResolvePendingOperations();
                if (!knownApp.DirectoryExists && knownApp.ReadAppMetadata() == null)
                {
                    deletedApps.Add(knownApp.AppName);
                }
            }
            foreach (string appName in deletedApps)
            {
                iKnownApps.Remove(appName);
            }
            //iInitialising = false;
            UpdateAppList();
            //iInitialising = true;
            InvokeAppStatusChanged(new AppStatusChangeEventArgs());
        }

        /// <summary>
        /// Install a plugin.
        /// </summary>
        /// <param name="aPersistentZipFile"></param>
        /// <remarks>
        /// The zip file should not be in a location writeable by anyone
        /// untrusted - no attempt is made to ensure that the file isn't
        /// modified while being read, meaning that malicious timing of
        /// modifications could be used to circumvent some verification.
        /// </remarks>
        public void Install(string aPersistentZipFile)
        {
            InternalInstall(null, aPersistentZipFile, true, true, "", null);
        }

        public void InstallNew(string aPersistentZipFile)
        {
            InternalInstall(null, aPersistentZipFile, false, true, "", null);
        }

        public void Upgrade(string aAppName, string aZipFile)
        {
            InternalInstall(aAppName, aZipFile, true, false, "", null);
        }

        public void InstallNew(string aPersistentZipFile, string aUrl, DateTime aLastModified)
        {
            InternalInstall(null, aPersistentZipFile, false, true, aUrl, aLastModified);
        }

        public void Upgrade(string aAppName, string aZipFile, string aUrl, DateTime aLastModified)
        {
            InternalInstall(aAppName, aZipFile, true, false, aUrl, aLastModified);
        }

        void InternalInstall(string aAppName, string aPersistentZipFile, bool aAllowUpgrade, bool aAllowInstall, string aUrl, DateTime? aLastModified)
        {
            string appDirName = iZipVerifier.VerifyPluginZip(aPersistentZipFile);
            if (aAppName != null && appDirName != aAppName)
            {
                throw new BadPluginException(String.Format("Expected plugin app name '{0}', but got '{1}' instead.", aAppName, appDirName));
            }
            var knownApp = GetOrCreateKnownApp(appDirName);
            if (knownApp.DirectoryExists && !aAllowUpgrade && !knownApp.ReadAppMetadata().DeletePending)
            {
                throw new BadPluginException(String.Format("Expected new install, but plugin collides with existing app '{0}'.", appDirName));
            }
            if (!knownApp.DirectoryExists && !aAllowInstall)
            {
                throw new BadPluginException(String.Format("Cannot apply upgrade, as app '{0}' is not installed.", appDirName));
            }
            knownApp.Upgrade(aPersistentZipFile);
            if (aLastModified != null)
            {
                var metadata = knownApp.ReadAppMetadata();
                metadata.AutoUpdate = true;
                metadata.UpdateUrl = aUrl;
                metadata.LastModified = aLastModified.Value;
                knownApp.WriteAppMetadata(metadata);
            }
            if (knownApp.ReadAppMetadata().InstallPending)
            {
                iNodeRebooter.SoftRestartNode();
            }
            else
            {
                UpdateAppList();
            }
            InvokeAppStatusChanged(new AppStatusChangeEventArgs());
        }

        public void UninstallByUdn(string aUdn)
        {
            UninstallByUdn(aUdn, true);
            UpdateAppList();
        }

        public void UninstallByAppName(string aAppName)
        {
            UninstallByAppName(aAppName, true);
        }

        public void UninstallAllApps()
        {
            throw new NotImplementedException();
        }

        private bool UninstallByUdn(string aUdn, bool aUpdateHistory)
        {
            string appName;
            if (!UdnsToAppNames.TryGetValue(aUdn, out appName))
            {
                return false;
            }
            return UninstallByAppName(appName, aUpdateHistory);
        }

        private bool UninstallByAppName(string aAppName, bool aUpdateHistory)
        {
            KnownApp app;
            if (!iKnownApps.TryGetValue(aAppName, out app))
            {
                return false;
            }
            if (app.IsPublished)
            {
                app.Unpublish();
            }

            AppNamesToUdns.Remove(aAppName); // Bimap cleans up inverse udn-to-appname.

            app.Delete();
            if (!app.DirectoryExists)
            {
                iKnownApps.Remove(aAppName);
            }

            InvokeAppStatusChanged(new AppStatusChangeEventArgs());

            return true;
        }

        public void Stop()
        {
            if (!iAppsStarted) return;
            List<Exception> exceptions = new List<Exception>();
            foreach (var app in iKnownApps.Values)
            {
                if (!app.IsPublished)
                {
                    continue;
                }
                try
                {
                    app.Unpublish();
                }
                catch (Exception e)
                {
                    exceptions.Add(e);
                }
            }
            if (exceptions.Count > 0)
            {
                throw new Exception(String.Format("{0} exceptions during Dispose().", exceptions.Count), exceptions[0]);
            }
            AppNamesToUdns.Clear();
            // !!!! write history to disk (here or earlier)
        }

        public void Dispose()
        {
            Stop();
        }

        private void AppAdded(DirectoryInfo aAppDirectoryInfo, IApp aApp)
        {
            if (!iAppsStarted) return;

            var app = aApp;

            var friendlyNameAttribute =
                app
                .GetType()
                .GetCustomAttributes(typeof(AppFriendlyNameAttribute), true)
                .Cast<AppFriendlyNameAttribute>()
                .FirstOrDefault();

            string appDirName = aAppDirectoryInfo.Name;

            string friendlyName =
                friendlyNameAttribute == null ?
                appDirName :
                friendlyNameAttribute.FriendlyName;

            if (app.PublishesNodeServices && iFullPrivilegeAppServices.NodeDeviceAccessor.Device.Enabled())
            {
                Logger.WarnFormat("App {0} wants to publish services on the node device, which is already enabled. It cannot run until the node is restarted.", appDirName);
                return;
            }

            // Take care here! We don't want an app peeking at other apps'
            // settings by injecting crazy XPath nonsense into its name.
            //string sanitizedName = GetSanitizedAppName(app);
            IConfigFileCollection appConfig = iConfiguration.GetSubcollection(
                el=>el
                    .Elements("app-settings")
                    .Where(e=>(string)e.Attribute("name")==appDirName)
                    .FirstOrDefault()
                );

            KnownApp knownApp = GetOrCreateKnownApp(appDirName);
            if (knownApp.IsPublished)
            {
                Logger.ErrorFormat("Bad app: multiple apps started from directory {0}.", appDirName);
                return;
            }

            AppMetadata appMetadata = knownApp.ReadAppMetadata();

            AppContext appContext = new AppContext(iFullPrivilegeAppServices,
                iAppsDirectory.GetAbsolutePathForSubdirectory(appDirName),
                iStoreDirectory.GetAbsolutePathForAppDirectory(appDirName), 
                appConfig,
                null,
                appDirName);

            // Init method removed as we no longer expect apps to provide their own
            // UDN.
            // Initialize the app to allow it to read its config files before we
            // query its Udn.
            //app.Init(appContext);

            string udn = appMetadata.Udn;

            if (string.IsNullOrEmpty(udn))
            {
                // The app doesn't provide a udn, and we don't have one stored
                // for it. Construct one.
                udn = Guid.NewGuid().ToString();
            }

            bool metadataDirty = false;

            if (friendlyName != appMetadata.FriendlyName)
            {
                appMetadata.FriendlyName = friendlyName;
                metadataDirty = true;
            }

            if (appMetadata.Udn != udn)
            {
                // The store needs to be updated with the new UDN
                appMetadata.Udn = udn;
                metadataDirty = true;
            }

            if (metadataDirty)
            {
                knownApp.WriteAppMetadata(appMetadata);
            }

            knownApp.IconUrl = app.IconUri;
            knownApp.Version = app.Version;

            IDvDevice device = CreateAppDevice(app, udn, appDirName);
            appContext.Device = device.RawDevice;

            var provider = iAppProviderConstructor(device.RawDevice, app, appDirName);
            var change = HistoryItem.ItemType.EInstall;

            // TODO: Fix History. It no longer bears any relation to how apps actually work.
            //if (!iInitialising && Uninstall(udn, false))
            //{
            //    change = HistoryItem.ItemType.EUpdate;
            //}

            try
            {
                Logger.InfoFormat("Starting app (UDN={0} directory={1}).", udn, appDirName);
                app.Start(appContext);
                Logger.InfoFormat("App started: (UDN={0}).", udn);
            }
            catch (Exception e)
            {
                Logger.ErrorFormat("Exception during app startup: {0}\n{1}", appDirName, e);
                throw;
            }
            device.SetEnabled();
            knownApp.Publish(new PublishedApp(app, device, provider));
            UdnsToAppNames[udn] = appDirName;
            iHistory.Add(new HistoryItem(appDirName, change, udn));
        }

        //static string GetSanitizedAppName(IApp app)
        //{
        //    return app.Name.Replace("'", "").Replace("\"", "").Replace("\\","-").Replace("/","-").Replace(":","").Replace(";","");
        //}

        IDvDevice CreateAppDevice(IApp app, string udn, string aAppDirName)
        {
            var resourceMgr = app.ResourceManager;
            IDvDevice device = (resourceMgr == null
                ? iFullPrivilegeAppServices.DeviceFactory.CreateDeviceStandard(udn)
                : iFullPrivilegeAppServices.DeviceFactory.CreateDeviceStandard(udn, resourceMgr));
            // Set initial values for the attributes mandated by UPnP
            // These may be over-ridden by the Start function below
            device.SetAttribute("Upnp.Domain", "openhome.org");
            device.SetAttribute("Upnp.Type", "App");
            device.SetAttribute("Upnp.Version", "1");
            device.SetAttribute("Upnp.FriendlyName", aAppDirName);
            device.SetAttribute("Upnp.Manufacturer", "N/A");
            device.SetAttribute("Upnp.ModelName", "ohOs Application");
            device.SetAttribute("Core.LongPollEnable", "");

            return device;
        }

        private void UpdateAppList()
        {
            if (!iAppsStarted) return;
            iAddinManager.UpdateRegistry(AppAdded, (aAppDir, aApp) => { });
        }

    }

    public class AppStatusChangeEventArgs : EventArgs
    {
    }
}
